package org.podval.docbook.gradle

import org.gradle.api.Project
import org.gradle.api.file.CopySpec
import java.io.File
import javax.xml.transform.stream.{StreamResult, StreamSource}
import org.apache.tools.ant.filters.ReplaceTokens
import org.xml.sax.InputSource
import scala.collection.JavaConverters._
import Util.writeInto

abstract class DocBook2 {

  def name: String

  def stylesheetName: String = name

  def usesIntermediate: Boolean

  def outputDirectoryName: String = name

  def intermediateDirectoryName: String = outputDirectoryName

  def outputFileExtension: String

  def intermediateFileExtension: String = outputFileExtension

  def parameterSections: Set[String] =
    Set(name, stylesheetName) ++
      (if (usesDocBookXslt2) Set.empty else  Set("common") ++ (if (!usesHtml) Set.empty else Set("htmlCommon")))

  def usesDocBookXslt2: Boolean

  def stylesheetUriName: String

  def usesHtml: Boolean

  def usesCss: Boolean

  def isEpub: Boolean = false

  final def writeStylesheetFiles(
    layout: Layout,
    parameters: Map[String, String],
    logger: Logger
  ): Unit = {
    val customStylesheetName: String = layout.customStylesheet(stylesheetName)
    val paramsStylesheetName: String = layout.paramsStylesheet(stylesheetName)
    val stylesheetUri: String = s"${Stylesheets(usesDocBookXslt2).uri}/$stylesheetUriName.xsl"

    // xsl:param has the last value assigned to it, so customization must come last;
    // since it is imported (so as not to be overwritten), and import elements must come first,
    // a separate "-param" file is written with the "default" values for the parameters :)

    writeInto(layout.stylesheetFile(layout.mainStylesheet(stylesheetName)), logger, replace = true) {
      s"""<?xml version="1.0" encoding="UTF-8"?>
         |<!-- DO NOT EDIT! Generated by the DocBook plugin.
         |     Customizations go into $customStylesheetName. -->
         |<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
         |  <xsl:import href="$stylesheetUri"/>
         |  <xsl:import href="$paramsStylesheetName"/>
         |  <xsl:import href="$customStylesheetName"/>
         |</xsl:stylesheet>
         |"""
    }

    writeInto(layout.stylesheetFile(paramsStylesheetName), logger, replace = true) {
      val parametersStr: String = parameters.map { case (name: String, value: String) =>
        s"""  <xsl:param name="$name">$value</xsl:param>"""
      }.mkString("\n")

      s"""<?xml version="1.0" encoding="UTF-8"?>
         |<!-- DO NOT EDIT! Generated by the DocBook plugin.
         |     Customizations go into $customStylesheetName. -->
         |<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
         |$parametersStr
         |</xsl:stylesheet>
         |"""
    }

    writeInto(layout.stylesheetFile(customStylesheetName), logger, replace = false) {
      s"""<?xml version="1.0" encoding="UTF-8"?>
         |<!-- Customizations go here. -->
         |<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
         |</xsl:stylesheet>
         |"""
    }
  }

  final def run(
    layout: Layout,
    isJEuclidEnabled: Boolean,
    inputFileName: String,
    substitutions: Map[String, String],
    resolver: Resolver,
    project: Project,
    logger: Logger
  ): Unit = {
    logger.info(s"\nProcessing DocBook to $name")

    // Saxon output directory and file.
    val saxonOutputDirectory: File = layout.saxonOutputDirectory(this)
    val saxonOutputFile: File = layout.saxonOutputFile(this, inputFileName)
    saxonOutputDirectory.mkdirs

    // Saxon
    Saxon.run(
      inputSource = new InputSource(layout.inputFile(inputFileName).toURI.toASCIIString),
      stylesheetSource = new StreamSource(layout.stylesheetFile(layout.mainStylesheet(stylesheetName))),
      outputTarget = new StreamResult(saxonOutputFile),
      resolver = resolver,
      processingInstructionsSubstitutions = substitutions,
      useXslt2 = usesDocBookXslt2,
      logger = logger
    )

    val copyDestinationDirectory: File = Util.subdirectory(saxonOutputDirectory, copyDestinationDirectoryName)

    // Images.
    logger.info(s"Copying images")
    project.copy((copySpec: CopySpec) => copySpec
      .into(copyDestinationDirectory)
      .from(layout.imagesDirectory.getParentFile)
      .include(layout.imagesDirectoryName + "/**")
    )

    // CSS.
    if (usesCss) {
      logger.info(s"Copying CSS")
      project.copy((copySpec: CopySpec) => copySpec
        .into(copyDestinationDirectory)
        .from(layout.cssDirectory.getParentFile)
        .include(layout.cssDirectoryName + "/**")
        .filter(Map("tokens" -> substitutions.asJava).asJava, classOf[ReplaceTokens])
      )
    }

    // Post-processing.
    if (usesIntermediate) {
      logger.info(s"Post-processing $name")
      val outputDirectory: File = layout.outputDirectory(this)
      outputDirectory.mkdirs

      postProcess(
        layout = layout,
        useDocBookXslt2 = usesDocBookXslt2,
        isJEuclidEnabled = isJEuclidEnabled,
        inputDirectory = saxonOutputDirectory,
        inputFile = saxonOutputFile,
        outputFile = layout.outputFile(this, inputFileName),
        logger = logger
      )
    }
  }

  def outputFileNameOverride: Option[String] = None

  def copyDestinationDirectoryName: Option[String] = None

  protected def postProcess(
    layout: Layout,
    useDocBookXslt2: Boolean,
    isJEuclidEnabled: Boolean,
    inputDirectory: File,
    inputFile: File,
    outputFile: File,
    logger: Logger
  ): Unit = {
  }
}

object DocBook2 {

  trait HtmlLike extends DocBook2 {
    final override def usesHtml: Boolean = true
    final override def usesCss: Boolean = true
    final override def usesIntermediate: Boolean = false
    final override def outputFileExtension: String = "html"
    final override def outputFileNameOverride: Option[String] = Some("index")
  }

  object Html extends DocBook2 with HtmlLike {
    override def usesDocBookXslt2: Boolean = false
    override def name: String = "html"
    override def stylesheetUriName: String = "html/chunkfast"
  }

  object Html2 extends DocBook2 with HtmlLike {
    override def usesDocBookXslt2: Boolean = true
    override def name: String = "html2"
    override def stylesheetUriName: String = "html/chunk"
  }

  object Pdf extends DocBook2 {
    override def usesDocBookXslt2: Boolean = false
    override def usesHtml: Boolean = false
    override def usesCss: Boolean = false

    override def usesIntermediate: Boolean = true
    override def intermediateDirectoryName: String = "fo"
    override def intermediateFileExtension: String = "fo"

    override def name: String = "pdf"
    override def outputFileExtension: String = "pdf"

    override def stylesheetUriName: String = "fo/docbook"

    override protected def postProcess(
      layout: Layout,
      useDocBookXslt2: Boolean,
      isJEuclidEnabled: Boolean,
      inputDirectory: File,
      inputFile: File,
      outputFile: File,
      logger: Logger
    ): Unit = Fop.run(
      configurationFile = layout.fopConfigurationFile,
      isJEuclidEnabled = isJEuclidEnabled,
      inputFile = inputFile,
      inputDirectory = inputDirectory,
      outputFile = outputFile,
      logger = logger
    )
  }

  trait Epub extends DocBook2 {
    final override def usesDocBookXslt2: Boolean = false
    final override def usesHtml: Boolean = true
    final override def usesCss: Boolean = false
    final override def isEpub: Boolean = true
    final override def usesIntermediate: Boolean = true
    final override def outputFileExtension: String = "epub"
    final override def copyDestinationDirectoryName: Option[String] = Some("OEBPS")

    final override protected def postProcess(
      layout: Layout,
      useDocBookXslt2: Boolean,
      isJEuclidEnabled: Boolean,
      inputDirectory: File,
      inputFile: File,
      outputFile: File,
      logger: Logger
    ): Unit = {
      val zip = new org.apache.tools.ant.taskdefs.Zip
      zip.setProject(new org.apache.tools.ant.Project)
      zip.setPreserve0Permissions(true)
      zip.setCompress(false)
      zip.setDestFile(outputFile)
      val fileSet = new org.apache.tools.ant.types.FileSet()
      fileSet.setDir(inputDirectory)
      fileSet.appendIncludes(Array("mimetype", "META-INF/**", "OEBPS/**"))
      zip.addFileset(fileSet)
      zip.execute()
    }
  }

  object Epub2 extends Epub {
    override def name: String = "epub2"
    override def stylesheetUriName: String = "epub/docbook"
  }

  object Epub3 extends Epub {
    override def name: String = "epub3"
    override def stylesheetUriName: String = "epub3/chunk"
  }

  val processors: List[DocBook2] = List(Html, Epub2, Epub3, Pdf, Html2)
}
