package org.opentorah.docbook.section

import java.io.File
import org.opentorah.mathjax
import org.opentorah.util.Json
import org.opentorah.xml.Xml
import Section.Parameters

trait DocBook2 extends Section {

  def defaultVariant: Variant = Variant(this, None)

  def usesIntermediate: Boolean = false

  def outputFileExtension: String

  def intermediateFileExtension: String = outputFileExtension

  // From general to specific
  final def parameterSections: List[Section] =  commonSections :+ this
  def commonSections: List[CommonSection]

  // Sanity check
  if (commonSections.contains(Common) && commonSections.contains(HtmlCommon) &&
    (commonSections != List(Common, HtmlCommon)))
    throw new IllegalArgumentException(s"Wrong section order for $this: $commonSections")

  def stylesheetUriName: String

  def usesRootFile: Boolean

  def mainStylesheet(
    paramsStylesheetName: String,
    stylesheetUri: String,
    nonOverridableParameters: Section.Parameters,
    customStylesheets: Seq[String],
    enableMathJax: Boolean
  ): String = {
    // xsl:param has the last value assigned to it, so customization must come last;
    // since it is imported (so as not to be overwritten), and import elements must come first,
    // a separate "-param" file is written with the "default" values for the parameters :)

    val customStylesheetsString: String = customStylesheets
      .map(customStylesheet =>  s"""  <xsl:import href="$customStylesheet"/>""")
      .mkString("\n")

    s"""${Xml.header}
       |<!-- DO NOT EDIT! Generated by the DocBook plugin. -->
       |<xsl:stylesheet $xslWithVersion>
       |  <xsl:import href="$stylesheetUri"/>
       |  <xsl:import href="$paramsStylesheetName"/>
       |$customStylesheetsString
       |
       |<!-- Non-overridable parameters -->
       |${toString(nonOverridableParameters)}
       |${mainStylesheetBody(enableMathJax)}
       |</xsl:stylesheet>
       |""".stripMargin
  }

  protected def mainStylesheetBody(isMathJaxEnabled: Boolean): String

  def paramsStylesheet(
    parameters: Seq[(String, Section.Parameters)]
 ): String = {
    val parametersStr: String = parameters.map { case (sectionName: String, sectionParameters: Section.Parameters) =>
      s"  <!-- $sectionName -->\n" + toString(sectionParameters)
    }.mkString("\n")

    s"""${Xml.header}
       |<!-- DO NOT EDIT! Generated by the DocBook plugin. -->
       |<xsl:stylesheet $xslWithVersion>
       |$parametersStr
       |</xsl:stylesheet>
       |""".stripMargin
  }

  private def toString(parameters: Parameters): String = parameters.map { case (name: String, value: String) =>
    if (value.nonEmpty) s"""  <xsl:param name="$name">$value</xsl:param>"""
    else s"""  <xsl:param name="$name"/>"""
  }.mkString("\n")

  def dynamicParameters(isInfoEnabled: Boolean): Map[Section, Section.Parameters] = Map.empty
    .updated(HtmlCommon, Seq[Option[(String, String)]](
      if (isInfoEnabled) None else parameter(_.chunkQuietlyParameter, "1")
    ).flatten.toMap)

  def nonOverridableParameters(
    saxonOutputDirectory: File,
    documentName: String,
    epubEmbeddedFontsString: String,
    cssFile: String,
    imagesDirectoryName: String,
    enableMathJax: Boolean,
    mathJaxConfiguration: mathjax.Configuration
  ): Section.Parameters = Seq[Option[(String, String)]](
    Some("img.src.path", imagesDirectoryName + "/"),
    parameter(_.baseDirParameter, saxonOutputDirectory.getAbsolutePath + "/"),
    parameter(_.rootFilenameParameter, rootFilename(documentName)),
    parameter(_.epubEmbeddedFontsParameter, epubEmbeddedFontsString),
    parameter(_.htmlStylesheetsParameter, cssFile),
    parameter(docBook2 =>
      if (!enableMathJax) None
      else docBook2.mathJaxConfigurationParameter, Json.fromMap(mathJaxConfiguration.toHtmlMap)
    )
  ).flatten.toMap

  protected def parameter(parameter: DocBook2 => Option[String], value: => String): Option[(String, String)] =
    parameter(this).map(_ -> value)

  protected def baseDirParameter: Option[String] = None
  protected def rootFilenameParameter: Option[String] = None
  final def usesCss: Boolean = htmlStylesheetsParameter.nonEmpty
  protected def htmlStylesheetsParameter: Option[String] = None
  protected def epubEmbeddedFontsParameter: Option[String] = None
  protected def chunkQuietlyParameter: Option[String] = None
  protected def mathJaxConfigurationParameter: Option[String] = None

  final def rootFilename(inputFileName: String): String =
    outputFileNameOverride.getOrElse(inputFileName)

  protected def outputFileNameOverride: Option[String] = None

  def copyDestinationDirectoryName: Option[String] = None

  def isPdf: Boolean = false

  def postProcess(
    inputDirectory: File,
    outputFile: File
  ): Unit = {
  }
}

object DocBook2 {

  val all: List[DocBook2] = List(Html, Epub2, Epub3, Pdf, Html2)

  def find(name: String): Option[DocBook2] = all.find(_.name.equalsIgnoreCase(name))

  def forName(name: String): DocBook2 = find(name).getOrElse {
    throw new IllegalArgumentException(
      s"""Unsupported output format $name;
         |supported formats are: ${getNames(all)}
         |""".stripMargin
    )
  }

  def getNames(processors: List[DocBook2]): String =
    processors.map(docBook2 => "\"" + docBook2.name +"\"").mkString("[", ", ", "]")
}
